---
title: 高度なパブリケーション
slug: advanced-publications
date: 0013/01/02
number: 13.5
points: 10
sidebar: true
photoUrl: http://www.flickr.com/photos/ikewinski/8390558986/
photoAuthor: Mike Lewinski
contents: パブリケーションを操作するためのより高度なパターンを学習。|どのように柔軟なパブリケーションとサブスクリプションが得ることができるかを知る。
paragraphs: 36
version: 1.7
---

ここまでであなたはパブリケーションとサブスクリプションがどのように相互作用するかをよく理解しているべきです。
それでは、補助輪を取り除き、より少数の高度なシナリオを検討します。

### コレクションを複数回のパブリッシュする

[パブリケーションに関する私たちの最初のサイドバー](/chapters/publications-and-subscriptions/)
にて、我々はより一般的なパブリケーションとサブスクリプションのパターンのいくつかを見て、
非常に簡単な自身のサイトに実装するための`_publishCursor`関数作成方法を学びました。


まずは、`_publishCursor`が正確に私たちのために何をするか思い出してみましょう:
それは、与えられたカーソルに一致するすべての文書を受け取り、
*同じ名前*のクライアントコレクションにそれらが来るようにしました。
_パブリケーション_の名前が関わるものではないことに注意してください。

これは、我々はすべてのコレクションのクライアントとサーバーのバージョンをリンクする
*複数の*パブリケーションを持つことができることを意味します。

我々はすでに我々が現在表示されている投稿に加えて、
全ての記事のページ番号付きサブセットを公開したときに、
[ページネーションの章](/chapter/pagination/)でこのパターンに遭遇しました。

別の同様のユースケースは、文書の大規模なセット、
ならびに単一の項目の完全な詳細の*概要*を公開することです：

<%= diagram "doublecollection", "Publishing a collection twice", "pull-center" %>

~~~js
Meteor.publish('allPosts', function() {
  return Posts.find({}, {fields: {title: true, author: true}});
});

Meteor.publish('postDetail', function(postId) {
  return Posts.find(postId);
});
~~~

クライアントはこれら二つのパブリケーションをサブスクライブした場合に、
その`'posts'`コレクションは2つのソースから取り込まれます：
最初のサブスクリプションからはタイトルと著者の名前、第二サブスクリプションからは
投稿の完全な詳細のリストです。

Now when the client subscribes to those two publications, its `'posts'` collection gets populated from two sources: a list of titles and author's names from the first subscription, and the full details of a post from the second.

`postDetail`によって公表後も（ただし、そのプロパティの一部のみで）
`allPosts`によって公開されていることを実現するかもしれない。
しかし、Meteorはフィールドを、オーバーラップの管理によってマージし重複なしの投稿を確保します。

You may realize that the post published by `postDetail` is also being published by `allPosts` (although with only a subset of its properties). However, Meteor takes care of the overlap by merging the fields and ensuring there is no duplicate post.

これは、素晴らしいです
なぜなら、我々は投稿の要約のリストをレンダリングする際に、
今必要なものを表示するために、
私たちのためだけの十分なデータを持っているデータオブジェクトを扱っているからです。
しかし、単一の投稿のためにページをレンダリングするとき、
我々はそれを表示するために必要なすべてを持っています。
もちろん、我々はすべてのフィールドが、この場合のすべての投稿で利用できることを期待しないように、
クライアント上で注意する必要があります - これは一般的な落とし穴です！

それはあなたがドキュメントプロパティを変化させることに制限されないということに留意すべきです。
非常によく、両方のパブリケーションに同じプロパティでパブリッシュしますが、
異なった順序のアイテムでした。

~~~js
Meteor.publish('newPosts', function(limit) {
  return Posts.find({}, {sort: {submitted: -1}, limit: limit});
});

Meteor.publish('bestPosts', function(limit) {
  return Posts.find({}, {sort: {votes: -1, submitted: -1}, limit: limit});
});
~~~
<%= caption "server/publications.js" %>

### Subscribing to a Publication Multiple Times

////
 
////
 
////
 
<%= diagram "subscribetwice", "Subscribing twice to one publication", "pull-center" %>

////
 
~~~js
Meteor.publish('posts', function(options) {
  return Posts.find({}, options);
});
~~~

////
 
~~~js
Meteor.subscribe('posts', {submitted: -1, limit: 10});
Meteor.subscribe('posts', {baseScore: -1, submitted: -1, limit: 10});
~~~

////
 
////
 
### Multiple Collections in a Single Subscription

////
 
////
 
////
 
////
 
////
 
////
 
////
 
<%= diagram "multiplecollections", "Two collections in one subscription", "pull-center" %>

~~~js
Meteor.publish('topComments', function(topPostIds) {
  return Comments.find({postId: topPostIds});
});
~~~

////
 
////
 
~~~js
Meteor.publish('topPosts', function(limit) {
  var sub = this, commentHandles = [], postHandle = null;
  
  // send over the top two comments attached to a single post
  function publishPostComments(postId) {
    var commentsCursor = Comments.find({postId: postId}, {limit: 2});
    commentHandles[post._id] = 
      Meteor.Collection._publishCursor(commentsCursor, sub, 'comments');
  }
    
  postHandle = Posts.find({}, {limit: limit}).observeChanges({
    added: function(id, post) {
      publishPostComments(post._id);
      sub.added('posts', id, post);
    },
    changed: function(id, fields) {
      sub.changed('posts', id, fields);
    },
    removed: function(id) {
      // stop observing changes on the post's comments
      commentHandles[id] && commentHandles[id].stop();
      // delete the post
      sub.removed('posts', id);
    }
  });
  
  sub.ready();
  
  // make sure we clean everything up (note `_publishCursor`
  //   does this for us with the comment observers)
  sub.onStop(function() { postsHandle.stop(); });
});
~~~

////
 
////
 
////
 
### Linking different collections

////
 
<%= diagram "linkedcollections", "One collection for two subscriptions", "pull-center" %>

////
 
////
 
////
 
////
 
~~~js
  Meteor.publish('videos', function() {
    var sub = this;
    
    var videosCursor = Resources.find({type: 'video'});
    Meteor.Collection._publishCursor(videosCursor, sub, 'videos');
    
    // _publishCursor doesn't call this for us in case we do this more than once.
    sub.ready();
  });
~~~

////
 
////
 