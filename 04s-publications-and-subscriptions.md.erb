---
title: パブリケーションとサブスクリプション
slug: publications-and-subscriptions
date: 0004/01/02
number: 4.5
points: 5
sidebar: true
photoUrl: http://www.flickr.com/photos/ikewinski/11264732804/
photoAuthor: Mike Lewinski
contents: どのようにパブリケーションとサブスクリプションが動くのか理解します。|デフォルトでのAutopublishパッケージがどんなことをするのか学びます|パターンの例をいくつか見ていきます。
paragraphs: 52
version: 1.7.1
---

パブリケーションとサブスクリプションは Meteor において、最も基本的で重要なコンセプトの１つです。
しかし、まだ始めたばかりでは理解することが難しいものです。

そのため多くの誤解の原因ともなっています。その誤解の中には Meteor は安全でないといったものや Meteor のアプリは大量のデータを扱えないといたものがあります。

最初にこうしたコンセプトに困惑してしまう理由の多くは、Meteor がもたらす「マジック」によるものです。
　Meteor のマジックは最終的にはとても役立つものですが、裏側で何をしているのかわかりません。（マジックってそういうものですからね）
　何か起きているのか理解するために、化けの皮を剥ぎ取りましょう。（？？？）

### 昔々

しかしはじめに、 Meteor が存在しなかった2011年の古き良き時代を振り返ってみましょう。
　例えば、あなたが Rails でアプリを作っていたとしましょう。
　ユーザーがサイトにやってくると、クライアントでは（つまり、あなたのブラウザーでは）、リクエストをサーバーにあるアプリに送ります。

このアプリの最初の仕事はユーザーが見る必要のあるデータが何であるか理解することです。
　これは検索結果の12ページであったり、メアリーのユーザープロフィール情報や、ボブの最近の20個のツイートといったものかもしれません。
　これは基本的にあなた要求した本を探すために、本屋の店員さんが通路を歩いて見て回ることのように考えることができます。

正しいデータを選び出したら、アプリの２つ目の仕事はデータを　
　（nice？＝素晴らしく？）人間が読むことのできる HTML に（translate？＝変換する？）ことです。
　（APIの場合はJSONに変換します。）

本屋でたとえると、これは購入した本を本をラッピングしてバックの中にしまうことです。
　これが有名な Model-View-Controller モデルでの"View"の部分です。

最終的に、アプリは HTML コードを取ってブラウザーへ送信します。
　これで Rails で作られたアプリの仕事は終わって、すべてのことが手元から離れました。
そのため、Rails で作られたアプリは次のリクエストが来るまで待っている間にビールを飲んでくつろぐことができます。（？？？）

### Meteor のやり方

Meteor がなぜ特別なのか比較して おさらいをしましょう（？？？）
　これまで見てきたように、Meteor の鍵となるイノベーションは Rails のアプリがサーバーでのみ動いているのに対して、
　Meteor アプリはクライアント（ブラウザー）でも動くクライアントサイドのコンポーネント（？？？）があります。　

<%= diagram "client-server", "Pushing a subset of the database to the client.", "pull-right" %>

これはまるで本屋の店員さんがあなたの欲しい本を見つけるだけでなく、
　家までついて来て夜中に読んでくれるようなものです。
　（ゾッとする話ですけどね。）

この構造は Meteor をクールなものにしています。Meteor がデータベースをどこからでも呼び出すという（chief among them？）
　簡単に言うと、 Meteorはあなたのデータベースから一部分を取ってきて、それをクライアントにコピーをします。

これには２つの大きな意味合いがあります。
１つ目は、クライントに HTML コードを送る代わりに、
　Meteor アプリが 実際の生データを送って、クライアントが対処するようにします。（data on the wire）
　２つ目は　サーバーへの往復を待つ必要がなく、すぐにデータにアクセスできます。(latency compensation)

### Publishing

アプリのデータベースはプライベートから機密データに至る何万ものドキュメントを入れることができます。　
　そのため、セキュリティやスケーラビリティの観点からもクライント上でデータベースのすべてを映し出すわけにはいきません。（？？？）

どのデータをクライントに送るか Meteor に命令する方法が必要で、publication がこの役目を果たします。（？？？）

Microscope にもどりましょう。　これがデータベースに入っているアプリの投稿のすべてです。（？？？）

<%= diagram "collections-1", "All the posts contained in our database.", "pull-center" %>

Microscopeにはそのような機能はないのですが、罵詈雑言にフラグを立てることを想定します。（？？？）
　データベースで保存したいのですが、ユーザーが使えないようにすべきでしょう。（すなわち、クライアントに送った）（？？？）

私たちの最初のタスクは　クライントにどんなデータを送りたいのかMeteorに指示を与えることです。
　フラグが立っていない投稿だけをpublishしたいということをMeteorに指示します。　

<%= diagram "collections-2", "Excluding flagged posts.", "pull-center" %>

これが対応するコードで、サーバー内にあります。

~~~js
// on the server
Meteor.publish('posts', function() {
  return Posts.find({flagged: false});
});
~~~

こうすることで、クライントはフラグを立てた投稿にアクセスできないようにします。
　まさにこれがMeteorアプリをセキュアにする方法です：
　単にクライアントにアクセスしてほしいデータをpublishするだけです。

<% note do %>

### DDP

基本的に、publication/subscriptionシステムについては
　サーバーサイドのコレクション（源）をクライアントサイドのコレクション（target？＝目的地？）に移動させるじょうごのようなものだと考えることができます。（？？？）

じょうごに（spoken over ？）するプロトコルはDDPと呼ばれます。（ Distributed Data Protocolといいます。）
　DDPについてさらに学習するには　リアルタイムカンファレンスでの Matt DeBergalis（Meteor発起人の一人）の講演を見ることができます。
　あるいは、Cris Matherの動画でもう少し詳細にこのコンセプトを理解することができます。（？？？）

<% end %>

### Subscribing

フラグの立っていない投稿をクライアントでも閲覧できるようにしたい場合、一度に幾千もの投稿を送ることはできません。（？？？）
　私たちは　クライアントが　今にもユーザーが必要としているデータの部分はどこなのか　規定する方法が必要であり、（？？？）
　まさにその場所に subscriptionを入れます。（？？？）

subscribeしているすべてのデータはMinimongoによってクライアントに反映されます。（？？？）
　MinimongoはMeteorのクライアントサイドでMongoDBを実行します。（？？？）

たとえば、私たちはボブ・スミスのプロフィールのページを見ているとしましょう。そして、彼の投稿だけを表示したいとします。

<%= diagram "collections-3", "Subscribing to Bob's posts will mirror them on the client.", "pull-center" %>

最初に、（parameter？＝引数？）を取るパブリケーションを改良します。

~~~js
// on the server
Meteor.publish('posts', function(author) {
  return Posts.find({flagged: false, author: author});
});
~~~

　私たちはアプリのクライアントサイドのコード内でパブリケーションにサブスクライブするときに引数を定義します。（？？？）

~~~js
// on the client
Meteor.subscribe('posts', 'bob-smith');
~~~

これがMeteorアプリをスケーラブルなクライアントサイドにする方法です。（？？？）
　使用可能なすべてのデータにサブスクライブする代わりに、今必要な部分だけを選び出します。
　このように、どれだけサーバーサイドのデータベースが大きいとしても、　ブラウザーのメモリのオーバーロードを回避します。

### Finding

ボブの投稿は多数のカテゴリーに散在しています。
　（たとえば、“JavaScript”や ”Ruby”、”Python”など）
　記念にボブの全ての投稿を読み込みたい（？？？）かもしれませんが、
　今現在は“JavaScriptしますテゴリーでの投稿だけを表示したいとします。
　ここから“finding”が登場です。

<%= diagram "collections-4", "Selecting a subset of documents on the client.", "pull-center" %>

サーバーで行ったのと同様に、 データの一部分を選択するためPosts.find() 関数を使います。

~~~js
// on the client
Template.posts.helpers({
  posts: function(){
    return Posts.find(author: 'bob-smith', category: 'JavaScript');
  }
});
~~~

パブリケーションとサブスクリプションの役割が何であるか把握しているので、
　より深く掘り下げて、共通する実行パターンを見なおしてみましょう。

### Autopublish

Meteorのプロジェクトをゼロから（つまり、meteor createを使って）作っているとしたら、
　自動的にautopublishパッケージが有効となっています。
　出発点として、autopublisが実際に何をしているのか、お話しましょう。（？？？）

クライアント上でサーバーから全てのデータを自動的に反映します。
　このようにして、パブリケーションとサブスクリプションを処理します。

<%= diagram "autopublish", "Autopublish", "pull-center"%>

どうやって動いているのでしょうか？　サーバー上に'posts'という名前のコレクションがあるとします。
　autopublishは自動的にMongoDB内のpostsコレクションを見つけた全ての投稿を　　
　クライアント上で'posts'という名前のコレクションに送ります（１つだと想定します。（？？？））

そのため、autopublishを使うなら、パブリケーションについて考える必要はありません。
　当然のことながら、データは誰からでもアクセスできます。
　もちろん、全てのユーザーマシンにキャッシュしたアプリのデータベースをまるごとコピーされてしまう問題があります。

こうした理由から、autopublishは開発を始めたときだけに適しています。　その時はまだパブリケーションについて検討しないで良いからです。

### すべての（？？？）コレクションをパブリッシュする。

autopublishを削除したら、　クライアントから全てのデータが消去されたことがすぐにわかるでしょう。
　元に戻す簡単な方法は、autopublishが行うことを複製して（？？？）、コレクションを丸ごとパブリッシュすることです。
　たとえば、

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find();
});
~~~

<%= diagram "fullcollection", "Publishing a full collection", "pull-center" %>

すべてのコレクションをパブリッシュしているわけですが、少なくともどのコレクションをパブリッシュするかを制御（？？？）しています。
　この場合は、Commentコレクションではなく、Postsコレクションをパブリッシュしています。

### コレクションの一部分をパブリッシュする

次の制御のレベルでは、コレクションの一部分だけをパブリッシュします。
　たとえば、ある著者に関連したpostsだけなら、（？？？）

~~~js
Meteor.publish('somePosts', function(){
  return Posts.find({'author':'Tom'});
});
~~~

<%= diagram "partialcollection", "Publishing a partial collection", "pull-center" %>

<% note do %>

### Behind The Scenes

もしあなたがMeteorのパブリケーションに関する公式資料を（？？？）読んだら、
　クライアント上で属性の記録を設定するための added() と ready()　を使った話に圧倒されるでしょう。（？？？）
　一度も使わないこれらのメソッドを見るMeteorアプリと折り合いをつけるのに四苦八苦することでしょう。（？？？）
　
その理由はMeteorがとても重要な _publishCursor()メソッドを提供しているからです。（？？？）
　これまでにこれが使われているのを見ましたか？
　おそらく直接は見ていませんが、あなたはパブリッシュ関数でカーソルを返しています。（言い換えると、Posts.find({'author':'Tom'})）
　まさにこれをMeteorが使っているのです。

MeteorがsomePostsパブリケーションがカーソルを返したところを見かけたら、
　お気づきのように、 _publishCursor()を呼び出して自動的にカーソルをパブリッシュします。（？？？）

_publishCursor()が行うことは次のようなことです。

-サーバーサイドのコレクションの名前をチェックします。
-カーソルからマッチするドキュメントを呼び出して、それを同じ名前のクライアントサイドのコレクションに送ります。（？？？）（これをするために.added()を使います。）
-ドキュメントが加えられたり、削除されたり、変更したときは、クライアントサイドのコレクションにその変更をおくります。
（カーソルでは.observe() を使い、.added()や.changed() 、 removed()を使います。）（？？？）

そのため、上記の例では、
クライアントサイドのキャッシュでユーザーの興味のある投稿（トムが書いたもの）だけが見れるようにすることができます　（？？？）

<% end %>

### Publishing Partial Properties

どのように投稿の一部分だけをパブリッシュするのか見てきました。
（？？？）、　どのようにして特定のプロパティだけをパブリッシュするのか見ていきましょう。

先ほどのように、
　find()を使って、カーソルを返しますが、今回は特定の領域（？？？）を除外します。

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({}, {fields: {
    date: false
  }});
});
~~~

<%= diagram "partialproperties", "Publishing partial properties", "pull-center" %>

もちろん、２つのテクニックを併用することもできます。
　たとえば、　（？？？）　はさておいて、トムの全ての投稿を返したいときは、このように書きます。

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({'author':'Tom'}, {fields: {
    date: false
  }});
});
~~~

### まとめ

あらゆるコレクションの全てのドキュメントのあらゆるプロパティをパブリッシュすることから始まって（autopublishも含めて）、
　コレクションの一部のドキュメントの一部のプロパティの一部だけをパブリッシュする方法を見ていきました。

どのようにMeteorでのパブリケーション処理の基本をカバーします。
　このシンプルなテクニックは　大部分のユースケースで対処できます。

時々、パブリケーションを　　融合させて　さらに踏み込む必要があります。（？？？）
　こうしたことは後の章でカバーしていきます。（？？？）
